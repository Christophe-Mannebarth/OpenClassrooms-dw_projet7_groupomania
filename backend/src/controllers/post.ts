// IMPORT PACKAGE
import fs from 'fs'

// IMPORT MODELs
import Post from '../models/Post'
import User from '../models/User'

import { Request, Response } from 'express'

// EXPORT ALL BUSINESS LOGIC CONCERNING POSTS:

// CREATE POST
/**
 * The request body contains a string "post",
 * which is simply a Post object converted to a string.
 * Parse it using JSON.parse() to get a usable object.
 * Deletes the field_userId from the request sent by the client.
 * Since "req.file.filename" only contains the filename segment,
 * resolves the full image URL.
 * Use "req.protocol" to get the first segment (in our case 'http').
 * Add '://', ​​then use "req.get('host')"
 * to resolve the server host (here, 'localhost:8000').
 * Finally add '/images/' and the filename to complete our URL.
 * The save() method saves the "Post" in the database,
 * and it returns a Promise.
 * Returns a success response with a 201 success code.
 * The catch() block returns a response with the error generated by Mongoose
 * as well as a 500 error code.
 * @param {Request} req  The request object
 * @param {Response} res  The response object
 */
export const createPost = async (req: Request, res: Response) => {
  try {
    const imageUrl = req.file
      ? `${req.protocol}://${req.get('host')}/images/${req.file.filename}`
      : null
    const postContent = req.body.postContent
    const title = req.body.title
    const author = req.body.author
    const post = new Post({
      //@ts-ignore
      userId: req.auth.userId,
      author: author,
      title: title,
      postContent: postContent,
      imageUrl: imageUrl,
    })
    post.save((error) => {
      if (!error) {
        return res.status(200).json({ message: 'Post créé avec succès !' })
      }
      if (!imageUrl) {
        return res.status(400).json({
          error: 'You must attach an image to your message',
          message: 'Vous devez joindre une image à votre message',
        })
      }
    })
  } catch (error) {
    return res.status(500).json({
      error,
      message: 'Une erreur serveur est survenue',
    })
  }
}

// DISPLAY ALL POSTS
/**
 * Use the find() method in the "Post" model
 * in order to return an array containing all the Posts in our database.
 * @param {Request} _req  The request object
 * @param {Response} res  The response object
 */
export const getAllPosts = async (_req: Request, res: Response) => {
  try {
    const posts = await Post.find({})
    return res.status(200).json(posts)
  } catch (error) {
    return res.status(500).json({
      error,
      message: 'Une erreur serveur est survenue',
    })
  }
}

// DISPLAY A POST WITH ITS ID
/**
 * Uses the findOne() method in the "Post" model to find the single "Post"
 * having the same "_id" as the query parameter.
 * This "Post" is then returned in a Promise and sent to the front-end.
 * If no "Post" is found or an error occurs:
 * sends a "404 error" to the front-end, along with the generated error.
 * @param {Request} req  The request object
 * @param {Response} res  The response object
 */
export const getOnePost = async (req: Request, res: Response) => {
  try {
    const post = await Post.findById({ _id: req.params.id })
    //@ts-ignore
    const authUserId = req.auth.userId
    const user = await User.findById({ _id: authUserId })
    const userName = user.username
    const isLiked = post.usersLiked.includes(userName)
    const isDisliked = post.usersDisliked.includes(userName)
    const likes = post.likes
    const dislikes = post.dislikes
    const usersLiked = post.usersLiked
    const usersDisliked = post.usersDisliked
    const data = {
      post: post,
      isLiked: isLiked,
      isDisliked: isDisliked,
      likes: likes,
      dislikes: dislikes,
      usersLiked: usersLiked,
      usersDisliked: usersDisliked,
    }
    if (!post) {
      throw res.status(404).json({
        error: 'Post does not exist !',
        message: "Ce message n'existe pas !",
      })
    }
    return res.status(200).json(data)
  } catch (error) {
    return res.status(500).json({
      error,
      message: 'Une erreur serveur est survenue',
    })
  }
}

// MODIFY A POST
/**
 * Create a "postObject" which checks if "req.body.post" exists or not.
 * If it exists, convert it to an Object.
 * if it does not exist, we simply process the incoming object.
 * Removes the _userId field sent by the client to avoid changing its owner
 * Then search the "post" by its ID,
 * and verifies that the requestor is the owner of the object or the administrator:
 *  - if its Ok:
 *    - check if "req.file" is asked:
 *      in this case a new image is processed and the old is deleted
 *      (return a status(500) with an error message if the picture does not exist)
 *    - Update the post
 *      (return a status(200) with a notification message)
 *  - if the requestor is not the owner of the object (the post):
 *    -  return a status(403) with a message
 * then makes the change.
 * @param {Request} req  The request object
 * @param {Response} res  The response object
 */
export const updatePost = async (req: Request, res: Response) => {
  try {
    const postId = req.params.id
    //@ts-ignore
    const authUserId = req.auth.userId
    const postObject = req.body.post ? JSON.parse(req.body.post) : req.body
    delete postObject._userId

    const post = await Post.findById({ _id: postId })
    const postUserId = post.userId
    const author = post.author

    const user = await User.findById({ _id: authUserId })
    const isAdmin = user.isAdmin

    if (postUserId === authUserId || isAdmin) {
      if (req.file) {
        const filename = post.imageUrl.split('/images/')[1]
        fs.unlink(`src/images/${filename}`, async (error) => {
          postObject.imageUrl = `${req.protocol}://${req.get('host')}/images/${
            req.file.filename
          }`
          if (error) {
            return res.status(500).json({
              error: 'Picture does not exist',
              message: "L'image n'exsite pas",
            })
          } else {
            await Post.findByIdAndUpdate(
              { _id: postId },
              {
                imageUrl: postObject.imageUrl,
              }
            )
          }
        })
      }
      await Post.findByIdAndUpdate(
        { _id: postId, author: author },
        { ...postObject, _id: postId, author: author }
      )
      return res
        .status(200)
        .json({ message: 'Message mis à jour avec succès !' })
    } else {
      return res.status(403).json({
        error: 'Unauthorized request',
        message: "Vous n'avez pas l'autorisation d'effectuer cette action",
      })
    }
  } catch (error) {
    return res.status(500).json({
      error,
      message: 'Une erreur serveur est survenue',
    })
  }
}

// DELETE A POST
/**
 * Use the ID received as a parameter to access the "Post"
 * corresponding in the database.
 * Checks if the user who made the deletion request
 * is the one who created the "Post".
 * Uses knowing that the image URL contains a segment
 * "/images/" to separate the filename.
 * Then use the unlink() function of the "fs" package
 * to delete this file by passing it the file to delete
 * and the callback to execute once this file is deleted.
 * In the callback, implement the original logic by removing
 * the "Post" of the database.
 * @param {Request} req  The request object
 * @param {Response} res  The response object
 */
export const deletePost = async (req: Request, res: Response) => {
  const postId = req.params.id
  //@ts-ignore
  const authUserId = req.auth.userId
  const post = await Post.findById({ _id: postId })
  const postUserId = post.userId
  const user = await User.findById({ _id: authUserId })
  const isAdmin = user.isAdmin
  const filename = post.imageUrl.split('/images/')[1]

  // If the ID of the requested post corresponds to the applicant's ID
  // OR if the applicant is administrator
  if (postUserId === authUserId || isAdmin) {
    // Remove the corresponding image of the requested post of the 'images' folder
    fs.unlink(`src/images/${filename}`, (error) => {
      if (error)
        res.status(500).json({ error, message: "L'image n'existe pas !" })
    })
    // withdraw the post from the database
    await Post.findByIdAndDelete({ _id: postId })
    return res.status(200).json({ message: 'Post deleted !' })
    // Otherwise return an error
  } else {
    return res.status(403).json({
      error: 'Unauthorized request.',
      message: "Vous n'avez pas l'autorisation d'effectuer cette action",
    })
  }
}

// SYSTEM LIKE & DISLIKE
/**
 * Check If user already like the post
 * If user not already liked or disliked:
 *  - Click on Like button:
 *    return 1 and add "userName" to "usersLiked"
 *    and increment "likes" by 1 like.
 *  - Click on Dislike button:
 *    return -1 and add "userName" to "usersdisLiked"
 *    and increment "dislikes" by 1 dislike.
 * If user has already liked:
 *  - Click on Like button:
 *    remove "userName" from "usersLiked"
 *    and decrement "likes" by -1 like
 * If user has already disliked:
 *  - Click on Dislike button:
 *    remove "userName" from "usersDisliked"
 *    and decrement "dislikes" by -1 dislike
 * @param {Request} req  The request object
 * @param {Response} res  The response object
 */
export const likePost = async (req: Request, res: Response) => {
  try {
    const like = req.body.like
    const postId = req.params.id
    //@ts-ignore
    const authUserId = req.auth.userId
    const post = await Post.findById({ _id: postId })
    const user = await User.findById({ _id: authUserId })
    const userName = user.username
    const isLiked = post.usersLiked.includes(userName)
    const isDisliked = post.usersDisliked.includes(userName)
    const usersLiked = post.usersLiked
    const usersDisliked = post.usersDisliked
    let likes = post.likes
    let dislikes = post.dislikes

    switch (like) {
      case 1:
        if (!isLiked || !isDisliked) {
          await Post.findByIdAndUpdate(
            { _id: postId },
            {
              $push: { usersLiked: userName },
              $inc: { likes: +1 },
            }
          )
          usersLiked.push(userName)

          const data = {
            isLiked: !isLiked,
            likes: (likes += 1),
            usersLiked: usersLiked,
          }
          return res.status(200).json(data)
        }
        break
      case -1:
        if (!isLiked || !isDisliked) {
          await Post.findByIdAndUpdate(
            { _id: postId },
            {
              $push: { usersDisliked: userName },
              $inc: { dislikes: +1 },
            }
          )
          usersDisliked.push(userName)

          const data = {
            isDisliked: !isDisliked,
            dislikes: (dislikes += 1),
            usersDisliked: usersDisliked,
          }
          return res.status(200).json(data)
        }
        break
      case 0:
        if (isLiked) {
          await Post.findByIdAndUpdate(
            { _id: postId },
            {
              $pull: { usersLiked: userName },
              $inc: { likes: -1 },
            }
          )
          const userNameIndex = usersLiked.indexOf(userName)
          usersLiked.splice(userNameIndex, 1)

          const data = {
            isLiked: !isLiked,
            likes: (likes -= 1),
            usersLiked: usersLiked,
          }
          return res.status(200).json(data)
        }

        if (isDisliked) {
          await Post.findByIdAndUpdate(
            { _id: postId },
            {
              $pull: { usersDisliked: userName },
              $inc: { dislikes: -1 },
            }
          )
          const userNameIndex = usersDisliked.indexOf(userName)
          usersDisliked.splice(userNameIndex, 1)

          const data = {
            isDisliked: !isDisliked,
            dislikes: (dislikes -= 1),
            usersDisliked: usersDisliked,
          }
          return res.status(200).json(data)
        }
        break
    }
  } catch (error) {
    res.status(500).json({ error, message: 'Une erreur serveur est survenue' })
  }
}
